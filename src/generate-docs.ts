import { TObject, TSchema, TUnion } from "@sinclair/typebox";
import fs from "fs";
import { objectKeys, titleCase } from "jaz-ts-utils";
import { JSONSchema4 } from "json-schema";
import { JSONSchemaFaker } from "json-schema-faker";
import { compile } from "json-schema-to-typescript";

import { TachyonConfig } from "@/generate-json-schemas";
import { EndpointConfig } from "@/generator-helpers.js";

JSONSchemaFaker.option("useExamplesValue", true);
JSONSchemaFaker.option("useDefaultValue", true);
let randomSeed = 0;

const autoGeneratedPrefix = `<!-- THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DO NOT EDIT IT MANUALLY -->\n\n`;

export async function generateDocs(tachyonConfig: TachyonConfig) {
    const tachyonSchema: Record<string, Record<string, EndpointConfig>> = {};
    const unionSchema = tachyonConfig.compiledSchema;

    objectKeys(tachyonConfig.schemaMeta.serviceIds).forEach((serviceId) => {
        for (const endpointId of tachyonConfig.schemaMeta.serviceIds[serviceId]) {
            if (!tachyonSchema[serviceId]) {
                tachyonSchema[serviceId] = {};
            }
            tachyonSchema[serviceId][endpointId] = tachyonConfig.commandConfigs[`${serviceId}/${endpointId}`].config;
        }
    });

    let schemaContents = "";
    for (const serviceId in tachyonSchema) {
        schemaContents += `    -   [${serviceId}](docs/schema/${serviceId}.md)\n`;
    }

    let mainReadme = await fs.promises.readFile("README.md", { encoding: "utf-8" });
    const regex = /(?<=COMMAND_SCHEMA_PLACEHOLDER_START.*$\n)[\s|\S]*(?=^.*COMMAND_SCHEMA_PLACEHOLDER_END.*)/ms;
    if (!mainReadme.match(regex)) {
        throw new Error("Could not find COMMAND_SCHEMA_PLACEHOLDER comment in main README.md");
    }
    mainReadme = mainReadme.replace(regex, schemaContents);
    await fs.promises.writeFile("README.md", mainReadme);

    for (const serviceId in tachyonSchema) {
        const serviceSchema = tachyonSchema[serviceId] as Record<string, EndpointConfig>;

        const orderedEndpointIds = Object.keys(serviceSchema).sort((a, b) => {
            const orderA = serviceSchema[a]?.order ?? Infinity;
            const orderB = serviceSchema[b]?.order ?? Infinity;

            return orderA - orderB;
        });

        const orderedEndpoints = {} as Record<string, TSchema>;
        for (const id of orderedEndpointIds) {
            orderedEndpoints[id] = tachyonConfig.commandConfigs[`${serviceId}/${id}`].schema;
        }

        const markdown = await generateServiceMarkdown(tachyonSchema, unionSchema, orderedEndpoints, serviceId);

        await fs.promises.writeFile(`docs/schema/${serviceId.toString()}.md`, markdown);
    }
}

export async function generateServiceMarkdown<T extends Record<string, TSchema>>(
    tachyonSchema: Record<string, Record<string, EndpointConfig>>,
    unionSchema: TUnion<TSchema[]>,
    endpoints: T,
    serviceId: string
): Promise<string> {
    let markdown = autoGeneratedPrefix;

    markdown += `# ${titleCase(serviceId)}\n\n`;

    if (fs.existsSync(`src/schema/${serviceId}/README.md`)) {
        const serviceReadme = await fs.promises.readFile(`src/schema/${serviceId}/README.md`, {
            encoding: "utf8",
        });

        markdown += `${serviceReadme}\n---\n`;
    }

    for (const endpointId in endpoints) {
        markdown += `- [${endpointId}](#${endpointId.toLowerCase()})\n`;
    }

    for (const endpointId in endpoints) {
        const endpointSchema = endpoints[endpointId];
        const endpointConfig = tachyonSchema[serviceId][endpointId];
        markdown += await generateEndpointMarkdown(endpointSchema, unionSchema, endpointConfig, serviceId, endpointId);
    }

    return markdown;
}

export async function generateEndpointMarkdown<T extends TSchema>(
    schema: T,
    unionSchema: TUnion<TSchema[]>,
    endpointConfig: EndpointConfig,
    serviceId: string,
    endpointId: string
): Promise<string> {
    let markdown = `---\n\n## ${titleCase(endpointId)}\n\n`;

    if (endpointConfig.description) {
        markdown += `${endpointConfig.description}\n\n`;
    }

    markdown += `- Endpoint Type: `;

    if ("request" in endpointConfig) {
        markdown += `**Request** -> **Response**\n`;
    } else {
        markdown += `**Event**\n`;
    }

    markdown += `- Source: **${titleCase(endpointConfig.source)}**\n`;
    markdown += `- Target: **${titleCase(endpointConfig.target)}**\n`;

    if (endpointConfig.scopes.length) {
        markdown += `- Required Scopes: \`${endpointConfig.scopes}\`\n\n`;
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (schema as any).definitions = unionSchema.definitions;

    if ("request" in endpointConfig) {
        markdown += await generateCommandMarkdown(schema, endpointConfig, serviceId, endpointId, "request");
        markdown += await generateCommandMarkdown(schema, endpointConfig, serviceId, endpointId, "response");
    } else if ("event" in endpointConfig) {
        markdown += await generateCommandMarkdown(schema, endpointConfig, serviceId, endpointId, "event");
    }

    return markdown;
}

export async function generateCommandMarkdown(
    schema: TSchema,
    endpointConfig: EndpointConfig,
    serviceId: string,
    endpointId: string,
    commandType: string
): Promise<string> {
    let markdown = `### ${titleCase(commandType)}\n\n`;

    markdown += `<details>
<summary>JSONSchema</summary>\n
\`\`\`json
${JSON.stringify(schema, null, 4)}
\`\`\`\n</details>\n\n`;

    const failedReasons: string[] = [];

    if (commandType === "response") {
        failedReasons.push(
            ...schema.anyOf.filter((res: TObject) => res.properties.status.const === "failed").map((res: TObject) => res.properties.reason.const)
        );
        schema = schema.anyOf.find((res: TObject) => res.properties.status.const === "success");
    }

    const finalSchema: JSONSchema4 = JSON.parse(JSON.stringify(schema, null, 4).replace(/"\$ref":\s*"([^"]+)"/g, `"$ref": "#/definitions/$1"`));

    JSONSchemaFaker.option("random", () => randomSeed);
    randomSeed += 0.01;

    const dummyData = await JSONSchemaFaker.resolve(finalSchema);
    markdown += `<details>
<summary>Example</summary>\n
\`\`\`json
${JSON.stringify(dummyData, null, 4)}
\`\`\`\n</details>\n\n`;

    try {
        let typings = await compile(finalSchema, `${titleCase(serviceId)}${titleCase(endpointId)}${titleCase(commandType)}`, {
            additionalProperties: false,
            bannerComment: ``,
            style: {
                bracketSpacing: true,
                tabWidth: 4,
                semi: true,
            },
        });
        typings = typings.replace(/\s*\/\*[\s\S]*?\*\/|(?<=[^:])\/\/.*|^\/\/.*/g, ""); // remove comments

        markdown += `#### TypeScript Definition
\`\`\`ts
${typings.trim()}
\`\`\`
`;

        if (failedReasons.length) {
            markdown += `Possible Failed Reasons: ${failedReasons.map((r) => `\`${r}\``).join(", ")}\n\n`;
        }
    } catch (err) {
        console.log(schema);
        throw err;
    }

    return markdown;
}
